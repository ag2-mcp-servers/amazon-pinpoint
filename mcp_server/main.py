# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T13:01:24+00:00



import argparse
import json
import os
from datetime import datetime
from typing import *
from typing import Optional, Union

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import APIKeyHeader, BaseSecurity
from fastapi import Header, Path, Query

from models import (
    BadRequestException,
    ConflictException,
    CreateAppResponse,
    CreateCampaignResponse,
    CreateEmailTemplateResponse,
    CreateExportJobResponse,
    CreateImportJobResponse,
    CreateInAppTemplateResponse,
    CreateJourneyResponse,
    CreatePushTemplateResponse,
    CreateRecommenderConfigurationResponse,
    CreateSegmentResponse,
    CreateSmsTemplateResponse,
    CreateVoiceTemplateResponse,
    DeleteAdmChannelResponse,
    DeleteApnsChannelResponse,
    DeleteApnsSandboxChannelResponse,
    DeleteApnsVoipChannelResponse,
    DeleteApnsVoipSandboxChannelResponse,
    DeleteAppResponse,
    DeleteBaiduChannelResponse,
    DeleteCampaignResponse,
    DeleteEmailChannelResponse,
    DeleteEmailTemplateResponse,
    DeleteEndpointResponse,
    DeleteEventStreamResponse,
    DeleteGcmChannelResponse,
    DeleteInAppTemplateResponse,
    DeleteJourneyResponse,
    DeletePushTemplateResponse,
    DeleteRecommenderConfigurationResponse,
    DeleteSegmentResponse,
    DeleteSmsChannelResponse,
    DeleteSmsTemplateResponse,
    DeleteUserEndpointsResponse,
    DeleteVoiceChannelResponse,
    DeleteVoiceTemplateResponse,
    ForbiddenException,
    GetAdmChannelResponse,
    GetApnsChannelResponse,
    GetApnsSandboxChannelResponse,
    GetApnsVoipChannelResponse,
    GetApnsVoipSandboxChannelResponse,
    GetApplicationDateRangeKpiResponse,
    GetApplicationSettingsResponse,
    GetAppResponse,
    GetAppsResponse,
    GetBaiduChannelResponse,
    GetCampaignActivitiesResponse,
    GetCampaignDateRangeKpiResponse,
    GetCampaignResponse,
    GetCampaignsResponse,
    GetCampaignVersionResponse,
    GetCampaignVersionsResponse,
    GetChannelsResponse,
    GetEmailChannelResponse,
    GetEmailTemplateResponse,
    GetEndpointResponse,
    GetEventStreamResponse,
    GetExportJobResponse,
    GetExportJobsResponse,
    GetGcmChannelResponse,
    GetImportJobResponse,
    GetImportJobsResponse,
    GetInAppMessagesResponse,
    GetInAppTemplateResponse,
    GetJourneyDateRangeKpiResponse,
    GetJourneyExecutionActivityMetricsResponse,
    GetJourneyExecutionMetricsResponse,
    GetJourneyResponse,
    GetPushTemplateResponse,
    GetRecommenderConfigurationResponse,
    GetRecommenderConfigurationsResponse,
    GetSegmentExportJobsResponse,
    GetSegmentImportJobsResponse,
    GetSegmentResponse,
    GetSegmentsResponse,
    GetSegmentVersionResponse,
    GetSegmentVersionsResponse,
    GetSmsChannelResponse,
    GetSmsTemplateResponse,
    GetUserEndpointsResponse,
    GetVoiceChannelResponse,
    GetVoiceTemplateResponse,
    InternalServerErrorException,
    ListJourneysResponse,
    ListTagsForResourceResponse,
    ListTemplatesResponse,
    ListTemplateVersionsResponse,
    MethodNotAllowedException,
    NotFoundException,
    PayloadTooLargeException,
    PhoneNumberValidateResponse,
    PutEventsResponse,
    PutEventStreamResponse,
    RemoveAttributesResponse,
    SendMessagesResponse,
    SendOTPMessageResponse,
    SendUsersMessagesResponse,
    TagKeys,
    TooManyRequestsException,
    UpdateAdmChannelResponse,
    UpdateApnsChannelResponse,
    UpdateApnsSandboxChannelResponse,
    UpdateApnsVoipChannelResponse,
    UpdateApnsVoipSandboxChannelResponse,
    UpdateApplicationSettingsResponse,
    UpdateBaiduChannelResponse,
    UpdateCampaignResponse,
    UpdateEmailChannelResponse,
    UpdateEmailTemplateResponse,
    UpdateEndpointResponse,
    UpdateEndpointsBatchResponse,
    UpdateGcmChannelResponse,
    UpdateInAppTemplateResponse,
    UpdateJourneyResponse,
    UpdateJourneyStateResponse,
    UpdatePushTemplateResponse,
    UpdateRecommenderConfigurationResponse,
    UpdateSegmentResponse,
    UpdateSmsChannelResponse,
    UpdateSmsTemplateResponse,
    UpdateTemplateActiveVersionResponse,
    UpdateVoiceChannelResponse,
    UpdateVoiceTemplateResponse,
    V1AppsApplicationIdAttributesAttributeTypePutRequest,
    V1AppsApplicationIdCampaignsCampaignIdPutRequest,
    V1AppsApplicationIdCampaignsPostRequest,
    V1AppsApplicationIdChannelsAdmPutRequest,
    V1AppsApplicationIdChannelsApnsPutRequest,
    V1AppsApplicationIdChannelsApnsSandboxPutRequest,
    V1AppsApplicationIdChannelsApnsVoipPutRequest,
    V1AppsApplicationIdChannelsApnsVoipSandboxPutRequest,
    V1AppsApplicationIdChannelsBaiduPutRequest,
    V1AppsApplicationIdChannelsEmailPutRequest,
    V1AppsApplicationIdChannelsGcmPutRequest,
    V1AppsApplicationIdChannelsSmsPutRequest,
    V1AppsApplicationIdChannelsVoicePutRequest,
    V1AppsApplicationIdEndpointsEndpointIdPutRequest,
    V1AppsApplicationIdEndpointsPutRequest,
    V1AppsApplicationIdEventsPostRequest,
    V1AppsApplicationIdEventstreamPostRequest,
    V1AppsApplicationIdJobsExportPostRequest,
    V1AppsApplicationIdJobsImportPostRequest,
    V1AppsApplicationIdJourneysJourneyIdPutRequest,
    V1AppsApplicationIdJourneysJourneyIdStatePutRequest,
    V1AppsApplicationIdJourneysPostRequest,
    V1AppsApplicationIdMessagesPostRequest,
    V1AppsApplicationIdOtpPostRequest,
    V1AppsApplicationIdSegmentsPostRequest,
    V1AppsApplicationIdSegmentsSegmentIdPutRequest,
    V1AppsApplicationIdSettingsPutRequest,
    V1AppsApplicationIdUsersMessagesPostRequest,
    V1AppsApplicationIdVerifyOtpPostRequest,
    V1AppsPostRequest,
    V1PhoneNumberValidatePostRequest,
    V1RecommendersPostRequest,
    V1RecommendersRecommenderIdPutRequest,
    V1TagsResourceArnPostRequest,
    V1TemplatesTemplateNameEmailPostRequest,
    V1TemplatesTemplateNameEmailPutRequest,
    V1TemplatesTemplateNameInappPostRequest,
    V1TemplatesTemplateNameInappPutRequest,
    V1TemplatesTemplateNamePushPostRequest,
    V1TemplatesTemplateNamePushPutRequest,
    V1TemplatesTemplateNameSmsPostRequest,
    V1TemplatesTemplateNameSmsPutRequest,
    V1TemplatesTemplateNameTemplateTypeActiveVersionPutRequest,
    V1TemplatesTemplateNameVoicePostRequest,
    V1TemplatesTemplateNameVoicePutRequest,
    VerifyOTPMessageResponse,
)

app = MCPProxy(
    contact={
        'email': 'mike.ralphson@gmail.com',
        'name': 'Mike Ralphson',
        'url': 'https://github.com/mermade/aws2openapi',
        'x-twitter': 'PermittedSoc',
    },
    description='Doc Engage API - Amazon Pinpoint API',
    license={'name': 'Apache 2.0 License', 'url': 'http://www.apache.org/licenses/'},
    termsOfService='https://aws.amazon.com/service-terms/',
    title='Amazon Pinpoint',
    version='2016-12-01',
    servers=[
        {
            'description': 'The Amazon Pinpoint multi-region endpoint',
            'url': 'http://pinpoint.{region}.amazonaws.com',
            'variables': {
                'region': {
                    'default': 'us-east-1',
                    'description': 'The AWS region',
                    'enum': [
                        'us-east-1',
                        'us-east-2',
                        'us-west-1',
                        'us-west-2',
                        'us-gov-west-1',
                        'us-gov-east-1',
                        'ca-central-1',
                        'eu-north-1',
                        'eu-west-1',
                        'eu-west-2',
                        'eu-west-3',
                        'eu-central-1',
                        'eu-south-1',
                        'af-south-1',
                        'ap-northeast-1',
                        'ap-northeast-2',
                        'ap-northeast-3',
                        'ap-southeast-1',
                        'ap-southeast-2',
                        'ap-east-1',
                        'ap-south-1',
                        'sa-east-1',
                        'me-south-1',
                    ],
                }
            },
        },
        {
            'description': 'The Amazon Pinpoint multi-region endpoint',
            'url': 'https://pinpoint.{region}.amazonaws.com',
            'variables': {
                'region': {
                    'default': 'us-east-1',
                    'description': 'The AWS region',
                    'enum': [
                        'us-east-1',
                        'us-east-2',
                        'us-west-1',
                        'us-west-2',
                        'us-gov-west-1',
                        'us-gov-east-1',
                        'ca-central-1',
                        'eu-north-1',
                        'eu-west-1',
                        'eu-west-2',
                        'eu-west-3',
                        'eu-central-1',
                        'eu-south-1',
                        'af-south-1',
                        'ap-northeast-1',
                        'ap-northeast-2',
                        'ap-northeast-3',
                        'ap-southeast-1',
                        'ap-southeast-2',
                        'ap-east-1',
                        'ap-south-1',
                        'sa-east-1',
                        'me-south-1',
                    ],
                }
            },
        },
        {
            'description': 'The Amazon Pinpoint endpoint for China (Beijing) and China (Ningxia)',
            'url': 'http://pinpoint.{region}.amazonaws.com.cn',
            'variables': {
                'region': {
                    'default': 'cn-north-1',
                    'description': 'The AWS region',
                    'enum': ['cn-north-1', 'cn-northwest-1'],
                }
            },
        },
        {
            'description': 'The Amazon Pinpoint endpoint for China (Beijing) and China (Ningxia)',
            'url': 'https://pinpoint.{region}.amazonaws.com.cn',
            'variables': {
                'region': {
                    'default': 'cn-north-1',
                    'description': 'The AWS region',
                    'enum': ['cn-north-1', 'cn-northwest-1'],
                }
            },
        },
    ],
)


@app.get(
    '/v1/apps',
    description=""" Retrieves information about all the applications that are associated with your Amazon Pinpoint account. """,
    tags=['campaign_activity_tracking'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_apps(
    page_size: Optional[str] = Query(None, alias='page-size'),
    token: Optional[str] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/apps',
    description="""  <p>Creates an application.</p> """,
    tags=['api_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_app(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1AppsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/apps/{application-id}',
    description=""" Deletes an application. """,
    tags=['app_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_app(
    application_id: str = Path(..., alias='application-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{application-id}',
    description=""" Retrieves information about an application. """,
    tags=['application_settings'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_app(
    application_id: str = Path(..., alias='application-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/apps/{application-id}/attributes/{attribute-type}',
    description=""" Removes one or more attributes, of the same attribute type, from all the endpoints that are associated with an application. """,
    tags=['app_management', 'application_settings'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def remove_attributes(
    application_id: str = Path(..., alias='application-id'),
    attribute_type: str = Path(..., alias='attribute-type'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1AppsApplicationIdAttributesAttributeTypePutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{application-id}/campaigns',
    description=""" Retrieves information about the status, configuration, and other settings for all the campaigns that are associated with an application. """,
    tags=['app_management', 'application_settings'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_campaigns(
    application_id: str = Path(..., alias='application-id'),
    page_size: Optional[str] = Query(None, alias='page-size'),
    token: Optional[str] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/apps/{application-id}/campaigns',
    description=""" Creates a new campaign for an application or updates the settings of an existing campaign for an application. """,
    tags=['campaign_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_campaign(
    application_id: str = Path(..., alias='application-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1AppsApplicationIdCampaignsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/apps/{application-id}/campaigns/{campaign-id}',
    description=""" Deletes a campaign from an application. """,
    tags=['campaign_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_campaign(
    application_id: str = Path(..., alias='application-id'),
    campaign_id: str = Path(..., alias='campaign-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{application-id}/campaigns/{campaign-id}',
    description=""" Retrieves information about the status, configuration, and other settings for a campaign. """,
    tags=['app_management', 'campaign_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_campaign(
    application_id: str = Path(..., alias='application-id'),
    campaign_id: str = Path(..., alias='campaign-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/apps/{application-id}/campaigns/{campaign-id}',
    description=""" Updates the configuration and other settings for a campaign. """,
    tags=['app_management', 'campaign_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_campaign(
    application_id: str = Path(..., alias='application-id'),
    campaign_id: str = Path(..., alias='campaign-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1AppsApplicationIdCampaignsCampaignIdPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{application-id}/campaigns/{campaign-id}/activities',
    description=""" Retrieves information about all the activities for a campaign. """,
    tags=['campaign_management', 'campaign_activity_tracking'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_campaign_activities(
    application_id: str = Path(..., alias='application-id'),
    campaign_id: str = Path(..., alias='campaign-id'),
    page_size: Optional[str] = Query(None, alias='page-size'),
    token: Optional[str] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{application-id}/campaigns/{campaign-id}/kpis/daterange/{kpi-name}',
    description=""" Retrieves (queries) pre-aggregated data for a standard metric that applies to a campaign. """,
    tags=['campaign_activity_tracking'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_campaign_date_range_kpi(
    application_id: str = Path(..., alias='application-id'),
    campaign_id: str = Path(..., alias='campaign-id'),
    end_time: Optional[datetime] = Query(None, alias='end-time'),
    kpi_name: str = Path(..., alias='kpi-name'),
    next_token: Optional[str] = Query(None, alias='next-token'),
    page_size: Optional[str] = Query(None, alias='page-size'),
    start_time: Optional[datetime] = Query(None, alias='start-time'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{application-id}/campaigns/{campaign-id}/versions',
    description=""" Retrieves information about the status, configuration, and other settings for all versions of a campaign. """,
    tags=['campaign_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_campaign_versions(
    application_id: str = Path(..., alias='application-id'),
    campaign_id: str = Path(..., alias='campaign-id'),
    page_size: Optional[str] = Query(None, alias='page-size'),
    token: Optional[str] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{application-id}/campaigns/{campaign-id}/versions/{version}',
    description=""" Retrieves information about the status, configuration, and other settings for a specific version of a campaign. """,
    tags=['campaign_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_campaign_version(
    application_id: str = Path(..., alias='application-id'),
    campaign_id: str = Path(..., alias='campaign-id'),
    version: str = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{application-id}/channels',
    description=""" Retrieves information about the history and status of each channel for an application. """,
    tags=['application_settings'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_channels(
    application_id: str = Path(..., alias='application-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/apps/{application-id}/channels/adm',
    description=""" Disables the ADM channel for an application and deletes any existing settings for the channel. """,
    tags=['app_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_adm_channel(
    application_id: str = Path(..., alias='application-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{application-id}/channels/adm',
    description=""" Retrieves information about the status and settings of the ADM channel for an application. """,
    tags=['app_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_adm_channel(
    application_id: str = Path(..., alias='application-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/apps/{application-id}/channels/adm',
    description=""" Enables the ADM channel for an application or updates the status and settings of the ADM channel for an application. """,
    tags=['app_management', 'channel_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_adm_channel(
    application_id: str = Path(..., alias='application-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1AppsApplicationIdChannelsAdmPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/apps/{application-id}/channels/apns',
    description=""" Disables the APNs channel for an application and deletes any existing settings for the channel. """,
    tags=['app_management', 'application_settings'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_apns_channel(
    application_id: str = Path(..., alias='application-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{application-id}/channels/apns',
    description=""" Retrieves information about the status and settings of the APNs channel for an application. """,
    tags=['application_settings'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_apns_channel(
    application_id: str = Path(..., alias='application-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/apps/{application-id}/channels/apns',
    description=""" Enables the APNs channel for an application or updates the status and settings of the APNs channel for an application. """,
    tags=['app_management', 'channel_management', 'application_settings'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_apns_channel(
    application_id: str = Path(..., alias='application-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1AppsApplicationIdChannelsApnsPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/apps/{application-id}/channels/apns_sandbox',
    description=""" Disables the APNs sandbox channel for an application and deletes any existing settings for the channel. """,
    tags=['app_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_apns_sandbox_channel(
    application_id: str = Path(..., alias='application-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{application-id}/channels/apns_sandbox',
    description=""" Retrieves information about the status and settings of the APNs sandbox channel for an application. """,
    tags=['app_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_apns_sandbox_channel(
    application_id: str = Path(..., alias='application-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/apps/{application-id}/channels/apns_sandbox',
    description=""" Enables the APNs sandbox channel for an application or updates the status and settings of the APNs sandbox channel for an application. """,
    tags=['application_settings', 'channel_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_apns_sandbox_channel(
    application_id: str = Path(..., alias='application-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1AppsApplicationIdChannelsApnsSandboxPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/apps/{application-id}/channels/apns_voip',
    description=""" Disables the APNs VoIP channel for an application and deletes any existing settings for the channel. """,
    tags=['app_management', 'application_settings'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_apns_voip_channel(
    application_id: str = Path(..., alias='application-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{application-id}/channels/apns_voip',
    description=""" Retrieves information about the status and settings of the APNs VoIP channel for an application. """,
    tags=['app_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_apns_voip_channel(
    application_id: str = Path(..., alias='application-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/apps/{application-id}/channels/apns_voip',
    description=""" Enables the APNs VoIP channel for an application or updates the status and settings of the APNs VoIP channel for an application. """,
    tags=['app_management', 'channel_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_apns_voip_channel(
    application_id: str = Path(..., alias='application-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1AppsApplicationIdChannelsApnsVoipPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/apps/{application-id}/channels/apns_voip_sandbox',
    description=""" Disables the APNs VoIP sandbox channel for an application and deletes any existing settings for the channel. """,
    tags=['app_management', 'user_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_apns_voip_sandbox_channel(
    application_id: str = Path(..., alias='application-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{application-id}/channels/apns_voip_sandbox',
    description=""" Retrieves information about the status and settings of the APNs VoIP sandbox channel for an application. """,
    tags=['application_settings'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_apns_voip_sandbox_channel(
    application_id: str = Path(..., alias='application-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/apps/{application-id}/channels/apns_voip_sandbox',
    description=""" Enables the APNs VoIP sandbox channel for an application or updates the status and settings of the APNs VoIP sandbox channel for an application. """,
    tags=['channel_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_apns_voip_sandbox_channel(
    application_id: str = Path(..., alias='application-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1AppsApplicationIdChannelsApnsVoipSandboxPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/apps/{application-id}/channels/baidu',
    description=""" Disables the Baidu channel for an application and deletes any existing settings for the channel. """,
    tags=['app_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_baidu_channel(
    application_id: str = Path(..., alias='application-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{application-id}/channels/baidu',
    description=""" Retrieves information about the status and settings of the Baidu channel for an application. """,
    tags=['application_settings'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_baidu_channel(
    application_id: str = Path(..., alias='application-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/apps/{application-id}/channels/baidu',
    description=""" Enables the Baidu channel for an application or updates the status and settings of the Baidu channel for an application. """,
    tags=['channel_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_baidu_channel(
    application_id: str = Path(..., alias='application-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1AppsApplicationIdChannelsBaiduPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/apps/{application-id}/channels/email',
    description=""" Disables the email channel for an application and deletes any existing settings for the channel. """,
    tags=['app_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_email_channel(
    application_id: str = Path(..., alias='application-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{application-id}/channels/email',
    description=""" Retrieves information about the status and settings of the email channel for an application. """,
    tags=['app_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_email_channel(
    application_id: str = Path(..., alias='application-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/apps/{application-id}/channels/email',
    description=""" Enables the email channel for an application or updates the status and settings of the email channel for an application. """,
    tags=['app_management', 'channel_management', 'message_sending'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_email_channel(
    application_id: str = Path(..., alias='application-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1AppsApplicationIdChannelsEmailPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/apps/{application-id}/channels/gcm',
    description=""" Disables the GCM channel for an application and deletes any existing settings for the channel. """,
    tags=['app_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_gcm_channel(
    application_id: str = Path(..., alias='application-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{application-id}/channels/gcm',
    description=""" Retrieves information about the status and settings of the GCM channel for an application. """,
    tags=['app_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_gcm_channel(
    application_id: str = Path(..., alias='application-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/apps/{application-id}/channels/gcm',
    description=""" Enables the GCM channel for an application or updates the status and settings of the GCM channel for an application. """,
    tags=['channel_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_gcm_channel(
    application_id: str = Path(..., alias='application-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1AppsApplicationIdChannelsGcmPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/apps/{application-id}/channels/sms',
    description=""" Disables the SMS channel for an application and deletes any existing settings for the channel. """,
    tags=['app_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_sms_channel(
    application_id: str = Path(..., alias='application-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{application-id}/channels/sms',
    description=""" Retrieves information about the status and settings of the SMS channel for an application. """,
    tags=['app_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_sms_channel(
    application_id: str = Path(..., alias='application-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/apps/{application-id}/channels/sms',
    description=""" Enables the SMS channel for an application or updates the status and settings of the SMS channel for an application. """,
    tags=[
        'app_management',
        'channel_management',
        'message_sending',
        'sms_template_management',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_sms_channel(
    application_id: str = Path(..., alias='application-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1AppsApplicationIdChannelsSmsPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/apps/{application-id}/channels/voice',
    description=""" Disables the voice channel for an application and deletes any existing settings for the channel. """,
    tags=['app_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_voice_channel(
    application_id: str = Path(..., alias='application-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{application-id}/channels/voice',
    description=""" Retrieves information about the status and settings of the voice channel for an application. """,
    tags=['app_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_voice_channel(
    application_id: str = Path(..., alias='application-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/apps/{application-id}/channels/voice',
    description=""" Enables the voice channel for an application or updates the status and settings of the voice channel for an application. """,
    tags=['app_management', 'channel_management', 'voice_template_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_voice_channel(
    application_id: str = Path(..., alias='application-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1AppsApplicationIdChannelsVoicePutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/apps/{application-id}/endpoints',
    description=""" Creates a new batch of endpoints for an application or updates the settings and attributes of a batch of existing endpoints for an application. You can also use this operation to define custom attributes for a batch of endpoints. If an update includes one or more values for a custom attribute, Amazon Pinpoint replaces (overwrites) any existing values with the new values. """,
    tags=['app_management', 'endpoint_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_endpoints_batch(
    application_id: str = Path(..., alias='application-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1AppsApplicationIdEndpointsPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/apps/{application-id}/endpoints/{endpoint-id}',
    description=""" Deletes an endpoint from an application. """,
    tags=['endpoint_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_endpoint(
    application_id: str = Path(..., alias='application-id'),
    endpoint_id: str = Path(..., alias='endpoint-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{application-id}/endpoints/{endpoint-id}',
    description=""" Retrieves information about the settings and attributes of a specific endpoint for an application. """,
    tags=['endpoint_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_endpoint(
    application_id: str = Path(..., alias='application-id'),
    endpoint_id: str = Path(..., alias='endpoint-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/apps/{application-id}/endpoints/{endpoint-id}',
    description=""" Creates a new endpoint for an application or updates the settings and attributes of an existing endpoint for an application. You can also use this operation to define custom attributes for an endpoint. If an update includes one or more values for a custom attribute, Amazon Pinpoint replaces (overwrites) any existing values with the new values. """,
    tags=['endpoint_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_endpoint(
    application_id: str = Path(..., alias='application-id'),
    endpoint_id: str = Path(..., alias='endpoint-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1AppsApplicationIdEndpointsEndpointIdPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{application-id}/endpoints/{endpoint-id}/inappmessages',
    description=""" Retrieves the in-app messages targeted for the provided endpoint ID. """,
    tags=['endpoint_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_in_app_messages(
    application_id: str = Path(..., alias='application-id'),
    endpoint_id: str = Path(..., alias='endpoint-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/apps/{application-id}/events',
    description=""" Creates a new event to record for endpoints, or creates or updates endpoint data that existing events are associated with. """,
    tags=['app_management', 'endpoint_management', 'event_stream_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def put_events(
    application_id: str = Path(..., alias='application-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1AppsApplicationIdEventsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/apps/{application-id}/eventstream',
    description=""" Deletes the event stream for an application. """,
    tags=['app_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_event_stream(
    application_id: str = Path(..., alias='application-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{application-id}/eventstream',
    description=""" Retrieves information about the event stream settings for an application. """,
    tags=['app_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_event_stream(
    application_id: str = Path(..., alias='application-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/apps/{application-id}/eventstream',
    description=""" Creates a new event stream for an application or updates the settings of an existing event stream for an application. """,
    tags=['event_stream_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def put_event_stream(
    application_id: str = Path(..., alias='application-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1AppsApplicationIdEventstreamPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{application-id}/jobs/export',
    description=""" Retrieves information about the status and settings of all the export jobs for an application. """,
    tags=['app_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_export_jobs(
    application_id: str = Path(..., alias='application-id'),
    page_size: Optional[str] = Query(None, alias='page-size'),
    token: Optional[str] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/apps/{application-id}/jobs/export',
    description=""" Creates an export job for an application. """,
    tags=['import_export_jobs'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_export_job(
    application_id: str = Path(..., alias='application-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1AppsApplicationIdJobsExportPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{application-id}/jobs/export/{job-id}',
    description=""" Retrieves information about the status and settings of a specific export job for an application. """,
    tags=['import_export_jobs'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_export_job(
    application_id: str = Path(..., alias='application-id'),
    job_id: str = Path(..., alias='job-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{application-id}/jobs/import',
    description=""" Retrieves information about the status and settings of all the import jobs for an application. """,
    tags=['app_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_import_jobs(
    application_id: str = Path(..., alias='application-id'),
    page_size: Optional[str] = Query(None, alias='page-size'),
    token: Optional[str] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/apps/{application-id}/jobs/import',
    description=""" Creates an import job for an application. """,
    tags=['import_export_jobs'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_import_job(
    application_id: str = Path(..., alias='application-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1AppsApplicationIdJobsImportPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{application-id}/jobs/import/{job-id}',
    description=""" Retrieves information about the status and settings of a specific import job for an application. """,
    tags=['import_export_jobs'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_import_job(
    application_id: str = Path(..., alias='application-id'),
    job_id: str = Path(..., alias='job-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{application-id}/journeys',
    description=""" Retrieves information about the status, configuration, and other settings for all the journeys that are associated with an application. """,
    tags=['app_management', 'application_settings'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_journeys(
    application_id: str = Path(..., alias='application-id'),
    page_size: Optional[str] = Query(None, alias='page-size'),
    token: Optional[str] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/apps/{application-id}/journeys',
    description=""" Creates a journey for an application. """,
    tags=['application_settings', 'journey_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_journey(
    application_id: str = Path(..., alias='application-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1AppsApplicationIdJourneysPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/apps/{application-id}/journeys/{journey-id}',
    description=""" Deletes a journey from an application. """,
    tags=['journey_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_journey(
    application_id: str = Path(..., alias='application-id'),
    journey_id: str = Path(..., alias='journey-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{application-id}/journeys/{journey-id}',
    description=""" Retrieves information about the status, configuration, and other settings for a journey. """,
    tags=['journey_management', 'app_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_journey(
    application_id: str = Path(..., alias='application-id'),
    journey_id: str = Path(..., alias='journey-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/apps/{application-id}/journeys/{journey-id}',
    description=""" Updates the configuration and other settings for a journey. """,
    tags=['journey_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_journey(
    application_id: str = Path(..., alias='application-id'),
    journey_id: str = Path(..., alias='journey-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1AppsApplicationIdJourneysJourneyIdPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{application-id}/journeys/{journey-id}/activities/{journey-activity-id}/execution-metrics',
    description=""" Retrieves (queries) pre-aggregated data for a standard execution metric that applies to a journey activity. """,
    tags=['journey_management', 'campaign_activity_tracking'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_journey_execution_activity_metrics(
    application_id: str = Path(..., alias='application-id'),
    journey_activity_id: str = Path(..., alias='journey-activity-id'),
    journey_id: str = Path(..., alias='journey-id'),
    next_token: Optional[str] = Query(None, alias='next-token'),
    page_size: Optional[str] = Query(None, alias='page-size'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{application-id}/journeys/{journey-id}/execution-metrics',
    description=""" Retrieves (queries) pre-aggregated data for a standard execution metric that applies to a journey. """,
    tags=['journey_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_journey_execution_metrics(
    application_id: str = Path(..., alias='application-id'),
    journey_id: str = Path(..., alias='journey-id'),
    next_token: Optional[str] = Query(None, alias='next-token'),
    page_size: Optional[str] = Query(None, alias='page-size'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{application-id}/journeys/{journey-id}/kpis/daterange/{kpi-name}',
    description=""" Retrieves (queries) pre-aggregated data for a standard engagement metric that applies to a journey. """,
    tags=['campaign_activity_tracking', 'journey_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_journey_date_range_kpi(
    application_id: str = Path(..., alias='application-id'),
    end_time: Optional[datetime] = Query(None, alias='end-time'),
    journey_id: str = Path(..., alias='journey-id'),
    kpi_name: str = Path(..., alias='kpi-name'),
    next_token: Optional[str] = Query(None, alias='next-token'),
    page_size: Optional[str] = Query(None, alias='page-size'),
    start_time: Optional[datetime] = Query(None, alias='start-time'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/apps/{application-id}/journeys/{journey-id}/state',
    description=""" Cancels (stops) an active journey. """,
    tags=['journey_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_journey_state(
    application_id: str = Path(..., alias='application-id'),
    journey_id: str = Path(..., alias='journey-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1AppsApplicationIdJourneysJourneyIdStatePutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{application-id}/kpis/daterange/{kpi-name}',
    description=""" Retrieves (queries) pre-aggregated data for a standard metric that applies to an application. """,
    tags=['campaign_activity_tracking'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_application_date_range_kpi(
    application_id: str = Path(..., alias='application-id'),
    end_time: Optional[datetime] = Query(None, alias='end-time'),
    kpi_name: str = Path(..., alias='kpi-name'),
    next_token: Optional[str] = Query(None, alias='next-token'),
    page_size: Optional[str] = Query(None, alias='page-size'),
    start_time: Optional[datetime] = Query(None, alias='start-time'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/apps/{application-id}/messages',
    description=""" Creates and sends a direct message. """,
    tags=['app_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def send_messages(
    application_id: str = Path(..., alias='application-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1AppsApplicationIdMessagesPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/apps/{application-id}/otp',
    description=""" Send an OTP message """,
    tags=['app_management', 'message_sending'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def send_o_t_p_message(
    application_id: str = Path(..., alias='application-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1AppsApplicationIdOtpPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{application-id}/segments',
    description=""" Retrieves information about the configuration, dimension, and other settings for all the segments that are associated with an application. """,
    tags=['app_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_segments(
    application_id: str = Path(..., alias='application-id'),
    page_size: Optional[str] = Query(None, alias='page-size'),
    token: Optional[str] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/apps/{application-id}/segments',
    description=""" Creates a new segment for an application or updates the configuration, dimension, and other settings for an existing segment that's associated with an application. """,
    tags=['app_management', 'application_settings'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_segment(
    application_id: str = Path(..., alias='application-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1AppsApplicationIdSegmentsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/apps/{application-id}/segments/{segment-id}',
    description=""" Deletes a segment from an application. """,
    tags=['segment_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_segment(
    application_id: str = Path(..., alias='application-id'),
    segment_id: str = Path(..., alias='segment-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{application-id}/segments/{segment-id}',
    description=""" Retrieves information about the configuration, dimension, and other settings for a specific segment that's associated with an application. """,
    tags=[
        'app_management',
        'campaign_management',
        'segment_management',
        'endpoint_management',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_segment(
    application_id: str = Path(..., alias='application-id'),
    segment_id: str = Path(..., alias='segment-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/apps/{application-id}/segments/{segment-id}',
    description=""" Creates a new segment for an application or updates the configuration, dimension, and other settings for an existing segment that's associated with an application. """,
    tags=['segment_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_segment(
    application_id: str = Path(..., alias='application-id'),
    segment_id: str = Path(..., alias='segment-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1AppsApplicationIdSegmentsSegmentIdPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{application-id}/segments/{segment-id}/jobs/export',
    description=""" Retrieves information about the status and settings of the export jobs for a segment. """,
    tags=['segment_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_segment_export_jobs(
    application_id: str = Path(..., alias='application-id'),
    page_size: Optional[str] = Query(None, alias='page-size'),
    segment_id: str = Path(..., alias='segment-id'),
    token: Optional[str] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{application-id}/segments/{segment-id}/jobs/import',
    description=""" Retrieves information about the status and settings of the import jobs for a segment. """,
    tags=['segment_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_segment_import_jobs(
    application_id: str = Path(..., alias='application-id'),
    page_size: Optional[str] = Query(None, alias='page-size'),
    segment_id: str = Path(..., alias='segment-id'),
    token: Optional[str] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{application-id}/segments/{segment-id}/versions',
    description=""" Retrieves information about the configuration, dimension, and other settings for all the versions of a specific segment that's associated with an application. """,
    tags=['segment_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_segment_versions(
    application_id: str = Path(..., alias='application-id'),
    page_size: Optional[str] = Query(None, alias='page-size'),
    segment_id: str = Path(..., alias='segment-id'),
    token: Optional[str] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{application-id}/segments/{segment-id}/versions/{version}',
    description=""" Retrieves information about the configuration, dimension, and other settings for a specific version of a segment that's associated with an application. """,
    tags=['app_management', 'segment_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_segment_version(
    application_id: str = Path(..., alias='application-id'),
    segment_id: str = Path(..., alias='segment-id'),
    version: str = ...,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{application-id}/settings',
    description=""" Retrieves information about the settings for an application. """,
    tags=['app_management', 'application_settings'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_application_settings(
    application_id: str = Path(..., alias='application-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/apps/{application-id}/settings',
    description=""" Updates the settings for an application. """,
    tags=['application_settings'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_application_settings(
    application_id: str = Path(..., alias='application-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1AppsApplicationIdSettingsPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/apps/{application-id}/users-messages',
    description=""" Creates and sends a message to a list of users. """,
    tags=['user_management', 'message_sending', 'app_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def send_users_messages(
    application_id: str = Path(..., alias='application-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1AppsApplicationIdUsersMessagesPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/apps/{application-id}/users/{user-id}',
    description=""" Deletes all the endpoints that are associated with a specific user ID. """,
    tags=['user_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_user_endpoints(
    application_id: str = Path(..., alias='application-id'),
    user_id: str = Path(..., alias='user-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/apps/{application-id}/users/{user-id}',
    description=""" Retrieves information about all the endpoints that are associated with a specific user ID. """,
    tags=['app_management', 'user_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_user_endpoints(
    application_id: str = Path(..., alias='application-id'),
    user_id: str = Path(..., alias='user-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/apps/{application-id}/verify-otp',
    description=""" Verify an OTP """,
    tags=['message_sending', 'user_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def verify_o_t_p_message(
    application_id: str = Path(..., alias='application-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1AppsApplicationIdVerifyOtpPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/phone/number/validate',
    description=""" Retrieves information about a phone number. """,
    tags=['user_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def phone_number_validate(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1PhoneNumberValidatePostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/recommenders',
    description=""" Retrieves information about all the recommender model configurations that are associated with your Amazon Pinpoint account. """,
    tags=['user_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_recommender_configurations(
    page_size: Optional[str] = Query(None, alias='page-size'),
    token: Optional[str] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/recommenders',
    description=""" Creates an Amazon Pinpoint configuration for a recommender model. """,
    tags=['recommender_configuration', 'recommender_configuration_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_recommender_configuration(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1RecommendersPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/recommenders/{recommender-id}',
    description=""" Deletes an Amazon Pinpoint configuration for a recommender model. """,
    tags=['recommender_configuration', 'recommender_configuration_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_recommender_configuration(
    recommender_id: str = Path(..., alias='recommender-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/recommenders/{recommender-id}',
    description=""" Retrieves information about an Amazon Pinpoint configuration for a recommender model. """,
    tags=['recommender_configuration', 'recommender_configuration_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_recommender_configuration(
    recommender_id: str = Path(..., alias='recommender-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/recommenders/{recommender-id}',
    description=""" Updates an Amazon Pinpoint configuration for a recommender model. """,
    tags=['recommender_configuration', 'recommender_configuration_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_recommender_configuration(
    recommender_id: str = Path(..., alias='recommender-id'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1RecommendersRecommenderIdPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/tags/{resource-arn}',
    description=""" Retrieves all the tags (keys and values) that are associated with an application, campaign, message template, or segment. """,
    tags=['resource_tag_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_tags_for_resource(
    resource_arn: str = Path(..., alias='resource-arn'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/tags/{resource-arn}',
    description=""" Adds one or more tags (keys and values) to an application, campaign, message template, or segment. """,
    tags=['resource_tag_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def tag_resource(
    resource_arn: str = Path(..., alias='resource-arn'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1TagsResourceArnPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/tags/{resource-arn}#tagKeys',
    description=""" Removes one or more tags (keys and values) from an application, campaign, message template, or segment. """,
    tags=['resource_tag_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def untag_resource(
    resource_arn: str = Path(..., alias='resource-arn'),
    tag_keys: TagKeys = Query(..., alias='tagKeys'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/templates',
    description=""" Retrieves information about all the message templates that are associated with your Amazon Pinpoint account. """,
    tags=['template_version_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_templates(
    next_token: Optional[str] = Query(None, alias='next-token'),
    page_size: Optional[str] = Query(None, alias='page-size'),
    prefix: Optional[str] = None,
    template_type: Optional[str] = Query(None, alias='template-type'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/templates/{template-name}/email',
    description=""" Deletes a message template for messages that were sent through the email channel. """,
    tags=['template_version_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_email_template(
    template_name: str = Path(..., alias='template-name'),
    version: Optional[str] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/templates/{template-name}/email',
    description=""" Retrieves the content and settings of a message template for messages that are sent through the email channel. """,
    tags=['template_version_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_email_template(
    template_name: str = Path(..., alias='template-name'),
    version: Optional[str] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/templates/{template-name}/email',
    description=""" Creates a message template for messages that are sent through the email channel. """,
    tags=[
        'email_template_management',
        'in_app_template_management',
        'push_template_management',
        'sms_template_management',
        'voice_template_management',
        'template_version_management',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_email_template(
    template_name: str = Path(..., alias='template-name'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1TemplatesTemplateNameEmailPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/templates/{template-name}/email',
    description=""" Updates an existing message template for messages that are sent through the email channel. """,
    tags=['email_template_management', 'template_version_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_email_template(
    create_new_version: Optional[bool] = Query(None, alias='create-new-version'),
    template_name: str = Path(..., alias='template-name'),
    version: Optional[str] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1TemplatesTemplateNameEmailPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/templates/{template-name}/inapp',
    description=""" Deletes a message template for messages sent using the in-app message channel. """,
    tags=['template_version_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_in_app_template(
    template_name: str = Path(..., alias='template-name'),
    version: Optional[str] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/templates/{template-name}/inapp',
    description=""" Retrieves the content and settings of a message template for messages sent through the in-app channel. """,
    tags=['template_version_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_in_app_template(
    template_name: str = Path(..., alias='template-name'),
    version: Optional[str] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/templates/{template-name}/inapp',
    description=""" Creates a new message template for messages using the in-app message channel. """,
    tags=['in_app_template_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_in_app_template(
    template_name: str = Path(..., alias='template-name'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1TemplatesTemplateNameInappPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/templates/{template-name}/inapp',
    description=""" Updates an existing message template for messages sent through the in-app message channel. """,
    tags=['in_app_template_management', 'template_version_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_in_app_template(
    create_new_version: Optional[bool] = Query(None, alias='create-new-version'),
    template_name: str = Path(..., alias='template-name'),
    version: Optional[str] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1TemplatesTemplateNameInappPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/templates/{template-name}/push',
    description=""" Deletes a message template for messages that were sent through a push notification channel. """,
    tags=['template_version_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_push_template(
    template_name: str = Path(..., alias='template-name'),
    version: Optional[str] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/templates/{template-name}/push',
    description=""" Retrieves the content and settings of a message template for messages that are sent through a push notification channel. """,
    tags=['template_version_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_push_template(
    template_name: str = Path(..., alias='template-name'),
    version: Optional[str] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/templates/{template-name}/push',
    description=""" Creates a message template for messages that are sent through a push notification channel. """,
    tags=['in_app_template_management', 'push_template_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_push_template(
    template_name: str = Path(..., alias='template-name'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1TemplatesTemplateNamePushPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/templates/{template-name}/push',
    description=""" Updates an existing message template for messages that are sent through a push notification channel. """,
    tags=[
        'push_template_management',
        'template_version_management',
        'in_app_template_management',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_push_template(
    create_new_version: Optional[bool] = Query(None, alias='create-new-version'),
    template_name: str = Path(..., alias='template-name'),
    version: Optional[str] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1TemplatesTemplateNamePushPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/templates/{template-name}/sms',
    description=""" Deletes a message template for messages that were sent through the SMS channel. """,
    tags=['template_version_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_sms_template(
    template_name: str = Path(..., alias='template-name'),
    version: Optional[str] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/templates/{template-name}/sms',
    description=""" Retrieves the content and settings of a message template for messages that are sent through the SMS channel. """,
    tags=['template_version_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_sms_template(
    template_name: str = Path(..., alias='template-name'),
    version: Optional[str] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/templates/{template-name}/sms',
    description=""" Creates a message template for messages that are sent through the SMS channel. """,
    tags=['sms_template_management', 'in_app_template_management', 'message_sending'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_sms_template(
    template_name: str = Path(..., alias='template-name'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1TemplatesTemplateNameSmsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/templates/{template-name}/sms',
    description=""" Updates an existing message template for messages that are sent through the SMS channel. """,
    tags=['template_version_management', 'sms_template_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_sms_template(
    create_new_version: Optional[bool] = Query(None, alias='create-new-version'),
    template_name: str = Path(..., alias='template-name'),
    version: Optional[str] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1TemplatesTemplateNameSmsPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v1/templates/{template-name}/voice',
    description=""" Deletes a message template for messages that were sent through the voice channel. """,
    tags=['template_version_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_voice_template(
    template_name: str = Path(..., alias='template-name'),
    version: Optional[str] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/templates/{template-name}/voice',
    description=""" Retrieves the content and settings of a message template for messages that are sent through the voice channel. """,
    tags=['template_version_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_voice_template(
    template_name: str = Path(..., alias='template-name'),
    version: Optional[str] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v1/templates/{template-name}/voice',
    description=""" Creates a message template for messages that are sent through the voice channel. """,
    tags=['voice_template_management', 'template_version_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_voice_template(
    template_name: str = Path(..., alias='template-name'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1TemplatesTemplateNameVoicePostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/templates/{template-name}/voice',
    description=""" Updates an existing message template for messages that are sent through the voice channel. """,
    tags=['voice_template_management', 'template_version_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_voice_template(
    create_new_version: Optional[bool] = Query(None, alias='create-new-version'),
    template_name: str = Path(..., alias='template-name'),
    version: Optional[str] = None,
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1TemplatesTemplateNameVoicePutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v1/templates/{template-name}/{template-type}/active-version',
    description=""" Changes the status of a specific version of a message template to <i>active</i>. """,
    tags=[
        'in_app_template_management',
        'push_template_management',
        'email_template_management',
        'sms_template_management',
        'voice_template_management',
        'template_version_management',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_template_active_version(
    template_name: str = Path(..., alias='template-name'),
    template_type: str = Path(..., alias='template-type'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: V1TemplatesTemplateNameTemplateTypeActiveVersionPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v1/templates/{template-name}/{template-type}/versions',
    description=""" Retrieves information about all the versions of a specific message template. """,
    tags=[
        'in_app_template_management',
        'push_template_management',
        'sms_template_management',
        'voice_template_management',
        'email_template_management',
        'template_version_management',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_template_versions(
    next_token: Optional[str] = Query(None, alias='next-token'),
    page_size: Optional[str] = Query(None, alias='page-size'),
    template_name: str = Path(..., alias='template-name'),
    template_type: str = Path(..., alias='template-type'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
